---
layout:     post
title:      tcp/ip的三次握手四次挥手
subtitle:   具体实现原理
date:       2020-08-09
author:     BY CHU GAO
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - javascript
    - 网络安全
    - object
---
# tcp/ip的三次握手四次挥手
## 报文格式
（ 图片引用自：https://blog.csdn.net/mary19920410/article/details/58030147 ）
- TCP报文格式
![avatar](https://img-blog.csdn.net/20170227111849763?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTWFyeTE5OTIwNDEw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
## TCP三次握手
TCP怎样才能保证可靠的传输任务，就是通过三次握手？
1. 首先由Client发出请求连接即 SYN=1 ACK=0  (请看头字段的介绍), TCP规定SYN=1时不能携带数据，但要消耗一个序号,因此声明自己的序号是 seq=x

2. 然后 Server 进行回复确认，即 SYN=1 ACK=1 seq=y, ack=x+1,

3. 再然后 Client 再进行一次确认，但不用SYN 了，这时即为 ACK=1, seq=x+1, ack=y+1.
![avatar](https://images2015.cnblogs.com/blog/964016/201608/964016-20160829221352886-141830767.png)
## TCP四次挥手
1. 当客户A 没有东西要发送时就要释放 A 这边的连接，A会发送一个报文（没有数据），其中 FIN 设置为1,  服务器B收到后会给应用程序一个信，这时A那边的连接已经关闭，即A不再发送信息（但仍可接收信息）。

2. A收到B的确认后进入等待状态，等待B请求释放连接， B数据发送完成后就向A请求连接释放，也是用FIN=1 表示， 并且用 ack = u+1(如图）， A收到后回复一个确认信息，并进入 TIME_WAIT 状态， 等待 2MSL 时间。

    
3. 为什么要等待呢？
     - 为了这种情况： B向A发送 FIN = 1 的释放连接请求，但这个报文丢失了， A没有接到不会发送确认信息， B 超时会重传，这时A在 WAIT_TIME 还能够接收到这个请求，这时再回复一个确认就行了。（A收到 FIN = 1 的请求后 WAIT_TIME会重新记时）

    - 另外服务器B存在一个保活状态，即如果A突然故障死机了，那B那边的连接资源什么时候能释放呢？  就是保活时间到了后，B会发送探测信息， 以决定是否释放连接。
![avatar](https://images2015.cnblogs.com/blog/964016/201608/964016-20160829222234683-593863018.png)

## 来个通俗版的解释
    1. tcp/ip协议是传输层面向链接的一个安全可靠的通信协议。

    2. 三次握手的机制是为了保证能建立一个安全可靠的连接。
       第一次握手是由客户端发起，客户端会向服务端发送一个报文，报文里面SYN = 1的；
       第二次握手当服务端收到这个报文之后就知道客户端要跟我发起一个新的连接，于是服务端就向客户端发送一个确认消息报文，这个消息报文里面ACH = 1；
       以上两次握手之后对于客户端而言，其实是已经知道了自己可以发送消息给服务端并且受到服务端返回的消息；但是对于服务端而言，两次握手之后服务端只知道能够接收到客户端发来的消息，不知道服务端本身发送的消息客户端能否接收到？
       第三次握手，当客户端收到服务端发送过来的确认消息的报文之后继续回应一个ACK = 1的确认消息。
       三次握手之后，这样服务端与客户端直接就建立了通信。
       
    3.四次挥手：第一次挥手客户端首先会发送一个FIN = 1的报文，当服务端接收到报文之后，知道了客户端想要与服务端断开连接，但是此时服务端不一定能做好准备，服务端可能有未发送完消息。
    第二次挥手所以此时服务端只能发送一个消息确认已经收到客户端发来的断开连接请求，
    第三次挥手等待服务端准备完成过后会继续发送一个FIN = 1的报文，表示服务端已经做好了断开连接的准备。
    第四次挥手客户端接收到了服务端发送过来FIN = 1的报文之后，给服务端发送一个消息确认的报文。
    经过了四次挥手之后通信被断开。




